# Limits - A simple, performant, and memory safe language

**This is currently a personal project and not intended for anyone elses eyes just yet.**

The language was created out of a desire to take what I feel are some great features from other contemporary languages and blend them to create a language which is as simple as possible to reason about and develop, with good concepts that translate well from human to machine understanding. I will include some examples in this repository of implementations, however, examples may not be consistent and for now this will just be a space to test out syntax and concepts.

*Editors note: As I start laying out features I think I am just converging on something close to a simple functional language.*

*Editors note 2: I am not an experienced programmer or language designer so all statements and observations are from my position of relative inexperience. There may be assumptions or statements which are not accurate so please do not take what's written here as anything other than opinion.*

## Language Design

### Things I'd like to borrow from other languages

- **Featureful cli building, testing and project management.** Examples include 'go' and 'cargo' which both mean competing third party build and test frameworks like cmake or ninja don't have to exist and be maintained. Having a good build and project management tool made in line with language decisions seems like a must for good developer experience.
- **Decisionful, first party linting.** Personally I really enjoy tools like rustfmt, gofmt, Black, and Prettier which all take the decision and ambiguity out of styling a codebase. There are enough decisions about code architecture that I'd rather not think about making what I write look good, safe in the knowledge that saving the file will clean it all up for me.
- **Easily machine parsable layout.** I think encoding meaning to specific layouts of whitespace (looking at you python) is a bad idea and burdens the developer with that requirement. I have always found languages that make tasteful use of delimiting characters for code blocks or enclosed meaning to be much more readable. This has the added benefit of, if done correctly, allowing a compiler to reason about the logic of the program with far less context (a condition is everything enclosed between the matching brackets).
- **Very fast compile time language.** Since this is a systems (at least inspired) language it will need to be compiled (I have a unique idea for compilation later). I want to keep the compile times low by design; I hope to achieve this by keeping the langauge fast to parse, with few language concepts to compute the interactions between.
- **Rich standard library.** While I have not interacted much with Golang, I really like the idea that there is a wide variety of standard implementations of commonly used features. This both speeds up development as people can utilise these features, but this also focuses a community around making one implementation fast and amazing, rather than relying on splintered and potentially dropped libraries.
- **Static/Dynamic compilation.** I think it is important to consider in the language design how programs could be dynamically linked from the outset. Ensuring a robust ABI structuer is defined early and then letting the developer decide whether to opt in to dynamically linking some libraries in a build configuration provides the flexibility to scale projects and build a large ecosystem.
- **A type system.** While there is more to say than just including one, I would like to have a type system while limiting the amount of object oriented paradygms possible with the language. I think that while object oriented programming is very powerful and has it's place comformably in many other languages, the concepts of seperation of concern, readability, and extensability can be expressed in simpler ways that are more hardware friendly. I think seperation of concern should not have to be something that the compiled binary should necessarily have to worry about either which can end up the case with things like interfaces and virtual functions.
- **Sum and product types.** From rust, I love the idea and they are simple to reason about. This provides a simple but flexible foundation of how non-repeating datatypes are laid out.
- **Rust match statements on sum types.** I love the syntax, it feels very natural from a control flow perspective and it allows great flexibility for defining code with different outcomes based on the data provided.
- **Rust standard option and result types.** Errors by value are great with the aforementioned match statments for expressive error handling and reflect that things going wrong in your program are expected and ok.
- **Standard operators.** While I think having object methods is a bad idea since they can also be expressed as methods that just take a data object, being able to implement standard operators such as +, \*, \[x\]... is a good idea. Among other things, it will allow for custom types to be implemented as an itteratable type which I will talk about later.
- **Traits.** This runs the risk of driving up complexity but in principle I like the idea of the data types being able to specify how they are used, such as copyable, itteratable, and so on. It could, for example, enforce that if an item was marked as itterable that the developer has implemented all the required methods, such as GetElement(). I might even go so far as to require that objects have to specify if they are able to be copied or moved scope at all.

### Personal ideas for the language

- **Limit the complexity of the language.** The languages namesake; I would like to keep the language with as few language features as possible and instead very carefully choose what features to include.
- **Data only types.** While controversial, I think that function implementation should be defined seperately to the data definition of types. Unlike something like c++ which implements methods as part of an object
- **Concurrency/parallelism model.** Good concurrency is basically a requirement for a modern programming language as much of the performance of modern programming comes from parallelism. Supposedly Golang has a great channel based model which I like and would like to recreate in a sensible way. I think having a way to share memory is also very important; as such I would like to have a clear explicit boundary between single threaded structures and concurrent supported ones where the compiler does not let single threaded structures cross the boundary into multi-threaded contexts.
- **Explicit heap and stack based allocation.** The stack and heap are important concepts and in some languages their usage is sometimes hidden behind other, often unrelated, keywords. I think having the heap's usage be explicit in some way will ease in understanding it's place in programs and would allow for developers to utilise the stack and heap more efficiently, or at least purposfully.
- **val and mut keywords.** I like how rust has brought mutability as not-a-given for variables and I think the concept of an unchanging value is useful. I like the idea of a seperate keyword for declaration between the two to make it readable without adding as much visual clutter. val's are set on declaration and are not changed for their lifetime whereas mut's can be reassigned.
- **For loops are just for itterators.** I'm not sure if any other languages have implemented this but I think for loops should just be for itterating over an itteratable value.
- **Few loop types.** It is a theme I am converging on but I think it would be nice to fit all the language syntax on a single page. I think I can get by with only the aforementioned for loop and a while loop. These loops should implement break and continue keywords though to allow for guard clauses and easy to reason control flow.
- **Async similar to parallelism.** I think the concept of waiting until you access a value for something common between async and parallel data access. Waiting for data in a queue, waiting for a mutex lock to be free and waiting for an asyncronous request to return are all similar in function and understanding. The concept of waiting for data is core to several modern programs and should probably look similar in code. As part of the standard library I think a lightweight async runtime is something that should be opt in if the program needs async, and like concurrency I think crossing the async boundary should be explicit but easy.
- **Scope manages lifetime.** I would like to try and simplify the rust ownership model as much as possible while still maintaining what makes it so good. Heap allocated objects (which are explicit in syntax as stated earlier) will have the same properties as stack allocated values insomuch as they will be dropped when they go out of scope. This will force the developer to consider more closely what objects are required in what scope, and if objects need to be passed up a scope then they will need to either be pre-declared as mutable or returned from the inner scope. This may be a limitation for functions that generate a bunch of data dynamically but I think generally it is better for a developer to understand what is creating, destroying and using data more carefully with scopes as the playgrounds for this. For performance I think objects should be able to be deleted in non branching code though.
- **All pointers are smart.** While I would like pointers to not be an exposed language concept, pointers in the context of heap allocated objects should always track the object they are referring to. Like shared\_ptr in c++, when all references to an object go out of scope, the object should be dropped.
- **Optional second-stage compiler.** I like the idea and performance advantages of JIT compilers but I think running a JIT compiler as standard would then require additional system dependancies and/or force a runtime onto those who don't want one. Instead I think having a best guess first stage compiler which operates like a normal compiler, but then optionally allow you to profile and optimise your assembly code with a second stage compiler would allow very performance critical applications like web servers to take runtime information such as heap value read/write frequency, function call frequency, and so on and further optimise which compilation decisions are made. There is also significant scope for machine learning in solving this second stage optimisation more holistically.

### Conclusions

The decisions above are all focused around making code that is as easy to reason about as possible while staying as close to how the machine will operate. This is to allow the compiled code to be performant and by keeping the language limited to simple implementations, compiling should be able to stay fast because the interplay of language concepts is limited by keeping the number of concepts low.

By keeping the implementation simple with as much context as possible, it should also be possible to have the compiler do a lot more optimisation for you, rather than relying on the developer to learn and stay aware of performant design. Performance decisions are still made available through use of things like the concurrent trait (which handles mutex access and so fourth and takes that performance hit) but these decisions are made with relation to the logical requirements, rather than the performance. By taking these performance changes away from the developer the compiler can decide if seperate read write locks are a better choice for you, offloading these performance knowledge burdens.

By keeping the language simple and letting the compiler make the tough performance decisions (optionally with runtime information) it should result in a language which can practically outperform languages like c++. I believe that this is because in complex problems, it is often sub-optimal developer decisions and architecture that limit performance, rather than inherent langauge design, but I may be incorrect and this is speculation.
